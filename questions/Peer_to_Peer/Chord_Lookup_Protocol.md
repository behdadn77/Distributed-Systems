

**Question:** *Describe the Chord lookup protocol. What information does each process store in its routing table? In the worst case, what is the maximum number of hops that a query traverses to find a given item? Motivate your answer.*

---

### Answer

#### 1. **Chord Lookup Protocol Overview**
The **Chord lookup protocol** is a distributed hash table (DHT) mechanism used for efficiently locating nodes and items in a peer-to-peer (P2P) system. Nodes and keys are organized in a logical ring structure. Each node and item in the system is assigned a unique \( m \)-bit identifier, typically generated by hashing the IP address (for nodes) or the item (for keys).

- **Item Storage**: An item with key \( k \) is stored at the node whose identifier is the smallest \( id \geq k \). This node is called the **successor** of \( k \).

---

### 2. **Routing Information Stored**
Each node in the Chord ring maintains the following information in its routing table:

1. **Successor**: Every node keeps track of its immediate successor in the ring. This ensures that even with minimal information, the system can maintain the ring structure and perform linear lookups.
2. **Finger Table**: To optimize the lookup process, each node maintains a **finger table** with \( m \) entries, where \( m \) is the number of bits in the identifier space.
   - **Entry \( i \) in the Finger Table**: The \( i \)-th entry of a node \( n \) points to the first node whose identifier is at least \( n + 2^i \) (for \( i = 0 \) to \( m - 1 \)).
   - This setup allows a node to forward queries exponentially closer to the desired key, reducing the number of hops needed for a lookup.

---

### 3. **Lookup Process**
When a node \( n \) receives a query for an item with key \( k \):
1. **Check Locally**: The node first checks if it is responsible for the key \( k \) (i.e., if \( k \) is between the nodeâ€™s identifier and its successor's identifier).
2. **Forward Query**: If the item is not stored locally, the node uses its finger table to forward the query. The query is sent to the largest node in the finger table that does not exceed \( k \), effectively halving the remaining distance to \( k \) in each step.

---

### 4. **Maximum Number of Hops (Worst Case)**
- In the **worst-case scenario**, a query traverses \( O(\log N) \) hops to find the desired item, where \( N \) is the total number of nodes in the system.
- **Motivation**:
  - Each hop in the lookup process reduces the distance to the target key by approximately half. Since the identifier space has \( N \) nodes and the distance can be halved at each step, the number of hops required is \( \log N \).
  - This logarithmic complexity is a result of the exponential leap provided by the finger table entries, which ensure that each query makes significant progress towards the target node.

---

### 5. **Joining New Nodes**
When a new node \( n \) joins the system:
1. **Initialization**: The new node \( n \) initializes its predecessor and finger table using information from an existing node \( n_0 \) already in the system.
2. **Updating Existing Nodes**: The predecessor and finger tables of other nodes are updated to reflect the addition of \( n \). This ensures that the lookup structure remains efficient.
3. **Time Complexity**: The joining process typically takes \( O(\log^2 N) \) hops with high probability to update all necessary nodes.

---

### Conclusion
The Chord lookup protocol efficiently handles queries in a distributed system using a **finger table** that allows for logarithmic lookup complexity, \( O(\log N) \), even in the worst case. Each node maintains a routing table of size \( O(\log N) \), which provides a scalable and efficient means of locating items in a large network. However, the system's performance can be affected by frequent node joins and departures, requiring consistent updates to maintain efficiency.